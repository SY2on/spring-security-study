[여기](#1)
# 1장

# 오늘날의 보안

[1.1 스프링 시큐리티: 개념과 장점](#11-스프링-시큐리티-개념과-장점)

[1.2 소프트웨어 보안이란?](#12-소프트웨어-보안이란)

[1.3 보안이 중요한 이유는 무엇인가?](#13-보안이-중요한-이유는-무엇인가)

[1.4 웹 애플리케이션의 일반적인 보안 취약성](#14-웹-애플리케이션의-일반적인-보안-취약성)

[1.4.1 인증과 권한 부여의 취약성](#141-인증과-권한-부여의-취약성)

[1.4.2 세션 고정](#142-세션-고정)

[1.4.3 XSS(교차 사이트 스크립팅)](#143-xss교차-사이트-스크립팅)

[1.4.4 CSRF(사이트 간 요청 위조)](#144-csrf사이트-간-요청-위조)

[1.4.5 주입](#145-주입)

[1.4.6 기밀 데이터 노출](#146-기밀-데이터-노출)

[1.4.7 메서드 접근 제어 부족](#147-메서드-접근-제어-부족)

[1.4.8 알려진 취약성이 있는 종속성 이용](#148-알려진-취약성이-있는-종속성-이용)

[1.5 다양한 아키텍처에 적용된 보안](#15-다양한-아키텍처에-적용된-보안)

[1.5.1 일체형 웹 애플리케이션 설계](#151-일체형-웹-애플리케이션-설계)

[1.5.2 백엔드/프론트엔드 분리를 위한 보안 설계](#152-백엔드프론트엔드-분리를-위한-보안-설계)

[1.5.3 OAuth2](#153-oauth2)

## 1.1 스프링 시큐리티: 개념과 장점

스프링 시큐리티는 스프링 애플리케이션에서 애플리케이션 수준의 보안을 구현할 때 가장 우선적인 선택이며 **인증, 권한 부여 및 일반적인 공격에 대한 방어**를 구현하는 세부적인 맞춤 구성 방법을 제공한다.

소스코드: [https://github.com/spring-projects/spring-security](https://github.com/spring-projects/spring-security)

어노테이션, 빈 등의 ‘스프링’ 방식의 구성스타일을 이용하여 어플리케이션 수준의 보안을 정의할 수 있다.

누가 작업을 수행하는지(인증), 특정 데이터를 이용할 수 있는지(인가)를 결정한다. 구성을 기반으로 요청을 가로채고 권한을 가진 사용자만 보호된 리소스에 접근할 수 있도록 스프링 시큐리티 구성 요소를 작성한다. 또한 구성 요소는 시스템의 다른 부분 간의 데이터 전송 및 저장 시 이 다른 부분에 대한 호출을 가로채서 데이터를 저장할 시 암호화나 해싱 알고리즘을 적용하는 등의 작업을 수행한다.  

## 1.2 소프트웨어 보안이란?

애플리케이션은 사용자의 다양한 정보를 관리하고 이 중 유출됐을 때 위험성이 높은 민감한 정보들도 포함되어 있다. 애플리케이션은 이러한 정보에 접근, 변경 또는 가로챌 기회가 없게 해야 하며 의도된 사용자 이외의 대상은 해당 데이터와 상호 작용할 수 없게 해야 한다. →  이것이 보안

보안은 계층별로 적용해야하며 각 계층에 다른 접근 방식이 필요하다.

이 중 애플리케이션 수준 보안은 애플리케이션이 실행되는 환경과 애플리케이션이 처리하고 저장하는 데이터를 보호하기 위해 해야하는 모든것을 나타낸다.

 

인증: 애플리케이션이 사용자를 식별하는 방법 → 인가를 위한 전 작업

인가: 해당 사용자는 무엇을 할 수 있는가

같은 구성요소의 다른 계층에도 권한 부여를 적용하는 것이 좋으며 데이터 저장시에도 개인키로 암호화한 데이터나 해시된 데이터로 저장해야한다.

실행중인 애플리케이션은 내부 메모리도 관리해야 한다. 애플리케이션의 힙에 저장된 데이터도 취약성의 원인일 수 있다. 앱이 자격 증명이나 개인 키 등의 민감한 데이터를 장시간 보관할 경우 힙 덤프 이용 권리가 있는 누군가가 악용할 수 있다.

**자바는 생성된 객체를 Heap 메모리에 보관한다.

** HeapDump는 특정 시점의 Heap 메모리 사용을 파일로 저장한 것.

## 1.3 보안이 중요한 이유는 무엇인가?

보안에 주의를 기울이지 않아 애플리케이션에서 관리하는 사용자의 데이터가 누출된다면 애플리케이션에 대한 신뢰 하락, 금전적 보상등의 대가가 따른다.

## 1.4 웹 애플리케이션의 일반적인 보안 취약성

애플리케이션의 취약성(Vulnerability) 목록

- 인증 취약성
- 세션 고정
- XSS(교차 사이트 스크립팅)
- CSRF(사이트 간 요청 위조)
- 주입
- 기밀 데이터 노출
- 메서드 접근 제어 부족
- 알려진 취약성이 있는 종속성 이용

### 1.4.1 인증과 권한 부여의 취약성

인증 취약성 → 사용자가 악의를 가지고 다른 사람의 기능이나 데이터에 접근할 수 있다

**본인의 데이터에만** 접근할 수 있도록 설계해야함

### 1.4.2 세션 고정

애플리케이션이 인증 프로세스 중에 고유한 세션 ID를 할당하지 않아 기존 세션 ID가 재사용될 가능성이 있을때 발견한다. ex)로그인 전의 세션 ID가 로그인 후에도 재사용됨

세션 고정 취약성이 존재하면 공격자는 이미 생성된 세션 ID를 재이용해 유효한 사용자를 가장할 수 있다.

1. 공격자가 사이트에서 세션 ID를 받음. 세션 ID=12345
2. 공격자는 응답받은 세션ID를 사용자에게 심어둔다.
3. 사용자는 해당 세션ID를 가지고 로그인
4. 서버는 인증 후 인증 객체를 세션ID=12345에 담아둔다.
5. 공격자는 인증 객체가 담긴 세션ID를 이용하여 사용자 행세

### 1.4.3 XSS(교차 사이트 스크립팅)

서버에 노출된 웹 서비스로 클라이언트 쪽 스크립트를 주입해 다른 사용자가 이를 실행하도록 하는 공격

1. A 사이트에 해커가 악성 스크립트(앱 B를 공격하는 스크립트)가 포함된 게시물 올림
2. 다른 방문자들이 해당 게시물 클릭
3. 방문자들의 브라우저는 악성 스크립트를 실행하게 되고 의도치 않게 DDoS에 가담

### 1.4.4 CSRF(사이트 간 요청 위조)

특정 서버에서 작업을 호출하는 URL을 추출해 애플리케이션의 외부에서 재사용할 수 있다고 가정

서버가 요청의 출처(어디 웹페이지에서 왔는지)를 확인하지 않고 무턱대고 실행하면 다른 모든 곳에서 요청이 실행될 수 있다.

공격자는 CSRF를 통해 동작을 숨겨서 사용자가 서버에 원치 않는 동작을 실행하도록 할 수 있다.

1. 사용자는 A서버에 로그인이 된 상태
2. 피싱사이트에 접속한 사용자
3. 피싱사이트는 스크립트에 A서버에 어떤 요청을 보내는 api를 숨김
4. 해당 스크립트를 누른 사용자는 자신도 모르게 A서버에 요청을 보내게 됨
5.  A서버는 해당 요청을 인증된 사용자의 요청으로 취급하고 처리함

### 1.4.5 주입

공격자는 시스템에 특정 데이터를 주입하는 취약성을 이용한다.

주입 공격에는 여러 종류가 있다. XSS도 주입 취약성 중 하나(악성 스크립트 주입)

SQL주입, XPath주입, OS 명령 주입, LDAP 주입 등등 많다.

### 1.4.6 기밀 데이터 노출

기밀데이터 - ex)개인키,

기밀 데이터는 스프링의 구성파일(application.properties, application.yml)에서 설정하면 X → 소스 코드를 볼 수 있는 모든 사람이 개인키값에 접근할 수 있기 때문, git에도 변경이 기록됨

로그에도 공개정보가 아닌것은 절대 기록하면 안된다.

[나쁜 로그 예]

```
[오류] 요청의 서명이 잘못 되었습니다. 사용할 올바른 키는 X입니다.
[경고] 사용자 이름 X와 암호 Y를 이용하여 로그인하지 못했습니다. 사용자 이름 X의 암호는 Z입니다.
[정보] 사용자 X가 올바른 암호 Y를 이용하여 로그인했습니다.
```

예외 발생 시에도 응답 본문에 예외가 나오면 안된다. → 예외를 통해 내부 구조를 파악할 수 있기 때문

다양한 입력에 대해 다른 메시지를 제공하는 것도 안됨! ex)사용자 아이디, 비밀번호 중 뭐가 틀렸는지 알려줌 X → 아이디 또는 비밀번호가 틀림 O

### 1.4.7 메서드 접근 제어 부족

권한 부여가 특정한 한 계층에서만 실행되는 것이 아닌 애플리케이션의 모든 계층에 권한 부여를 적용해야한다.

ex) Controller에서만 권한 부여 로직 적용 X → Controller, Service, Repository 모든 계층에 권한 부여 로직 적용 O

### 1.4.8 알려진 취약성이 있는 종속성 이용

이용하는 종속성에 취약성이 있는지 살피고 알려진 취약성이 있는 버전은 제거해야한다

## 1.5 다양한 아키텍처에 적용된 보안

시스템 디자인에 따라 스프링 시큐리티 구성이 다르다.

### 1.5.1 일체형 웹 애플리케이션 설계

백엔드, 프론트 엔드의 직접적인 분리가 없는 경우

서버 세션이 존재함

→ 세션 고정 취약성, CSRF, HTTP 세션에 뭘 저장할지도 고민해야 함

서버 세션은 준 영구적이며 데이터의 상태를 저장하므로 수명이 길다

→ 메모리에 유지되는 시간이 길수록 통계적으로 접근가능성 커짐 

→ 힙 덤프에 접근할 수 있는 사람은 앱의 내부 메모리에 있는 정보(개인키값, 사용자 데이터…)를 읽을 수 있음

### 1.5.2 백엔드/프론트엔드 분리를 위한 보안 설계

서버 세션을 클라이언트 세션으로 대체하는 것이 좋다

### 1.5.3 OAuth2

권한 부여 서버와 리소스 서버가 존재

권한부여 서버 : 사용자에게 권한을 부여하고 권한 정보가 들어있는 토큰 제공

리소스 서버 : 사용자의 토큰을 확인 후 리소스 제공 혹은 거부

1. 사용자가 애플리케이션의 기능에 접근. 애플리케이션은 백엔드의 리소스를 호출해야함
2. 리소스 호출을 위해서는 액세스 토큰 필요. 권한부여 서버를 호출하여(사용자 자격 증명 혹은 갱신 토큰을 보냄) 토큰 획득
3. 자격 증명이나 갱신토큰 확인 후 권한 부여 서버가 새로운 액세스 토큰 반환
4. 리소스 호출시 요청의 헤더에 액세스 토큰 이용

OAuth2의 장점

- 클라이언트는 사용자 자격 증명(아이디, 비밀번호..)을 저장할 필요 없이 액세스 토큰과 갱신토큰만 저장하면 된다.
- 애플리케이션은 사용자 자격 증명을(네트워크에서) 노출하지 않는다.
- 누군가 토큰을 탈취시 자격증명을 건들 필요 없이 토큰을 실격시키면 된다
- 토큰을 이용하면 제삼자가 사용자를 가장하지 않아도 사용자 대신 리소스에 접근 가능하다(공격자가 해당 토큰을 탈취해도 수명 제한이 있음)